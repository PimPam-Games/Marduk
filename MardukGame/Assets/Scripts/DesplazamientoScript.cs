
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.269
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
public class DesplazamientoScript : MonoBehaviour {

	/// <summary>
	/// velocidad de desplazamiento
	/// </summary>
	public Vector2 velocidad = new Vector2(2, 2);
	
	/// <summary>
	/// direccion de mvomiento
	/// </summary>
	public Vector2 direccion = new Vector2(0, -1);
	
	/// <summary>
	/// Si el movimiento deberia ser aplicado a la camara
	/// </summary>
	public bool estaUnidoaLaCamara = false;
	
	/// <summary>
	/// la imagen sera infinita? para el fondo
	/// </summary>
	public bool esCiclico = false;
	
	/// <summary>
	/// Lista de objetos renderizados
	/// </summary>
	private List<Transform> objetoCiclico;
	
	// Traemos a todos los objetos renderizados
	void Start()
	{
		// Si es ciclico / fondo infinito
		if (esCiclico)
		{
			// Traemos todos los objetos hijos del objeto ciclico
			objetoCiclico = new List<Transform>();
			
			for (int i = 0; i < transform.childCount; i++)
			{
				Transform hijo = transform.GetChild(i);
				
				// Add only the visible children
				if (hijo.GetComponent<Renderer>() != null)
				{
					objetoCiclico.Add(hijo);
				}
			}
			
			// Ordenamos por posicion
			// Ordenamos de izquierda a derecha
			objetoCiclico = objetoCiclico.OrderBy(
				t => t.position.y
				).ToList();
		}
	}

	void Update()
	{
		// movimiento
		Vector3 movimiento = new Vector3(
			velocidad.x * direccion.x,
			velocidad.y * direccion.y,
			0);
		
		movimiento *= Time.deltaTime;
		transform.Translate(movimiento);
		
		// Mover la camara
		if (estaUnidoaLaCamara)
		{
			Camera.main.transform.Translate(movimiento);
		}

		// Ciclico
		if (esCiclico)
		{
			// Traemos el primer objeto desde la izquierda
			Transform primerObjeto = objetoCiclico.FirstOrDefault();
			
			if (primerObjeto != null)
			{
				// Vemos si el objeto ya salio de la camara
				// Ojo que la funcion IsVisibleFrom es pesada
				if (primerObjeto.position.x < Camera.main.transform.position.x)
				{
					// Si el objeto salio del enfoque de la camara
					if (primerObjeto.GetComponent<Renderer>().isVisible == false)
					{
						// Obtenemos la posicion del ultimo objeto.
						Transform ultimoObjeto = objetoCiclico.LastOrDefault();
						Vector3 ultimaPosicion = ultimoObjeto.transform.position;
						Vector3 ultimoTamano = (ultimoObjeto.GetComponent<Renderer>().bounds.max - ultimoObjeto.GetComponent<Renderer>().bounds.min);
						
						// Lo colocamos en la posicion despues del ultimo
						// Nota: Esto solo funciona con el desplazamiento horizontal.
						primerObjeto.position = new Vector3(ultimaPosicion.x + ultimoTamano.x ,primerObjeto.position.y, primerObjeto.position.z);
						
						// Removemos el primer objeto
						// y lo volvemos agregar con la nueva posicion
						objetoCiclico.Remove(primerObjeto);
						objetoCiclico.Add(primerObjeto);
					}
				}
			}
		}
	}
}
